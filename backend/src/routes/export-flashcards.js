import express from "express";
import { jsPDF } from "jspdf";
import PptxGenJS from "pptxgenjs";
import JSZip from "jszip";
import { createCanvas } from "canvas";

const router = express.Router();

// Helper function for text wrapping
function wrapText(context, text, x, y, maxWidth, lineHeight) {
  const words = text.split(' ');
  let line = '';
  let currentY = y;
  
  for (let n = 0; n < words.length; n++) {
    const testLine = line + words[n] + ' ';
    const metrics = context.measureText(testLine);
    const testWidth = metrics.width;
    
    if (testWidth > maxWidth && n > 0) {
      context.fillText(line, x, currentY);
      line = words[n] + ' ';
      currentY += lineHeight;
    } else {
      line = testLine;
    }
  }
  context.fillText(line, x, currentY);
}

// PowerPoint Export - Fixed
router.post("/ppt", async (req, res) => {
  try {
    const { flashcards, fileName } = req.body;
    
    const pptx = new PptxGenJS();
    
    // Set presentation metadata
    pptx.author = "StudyMate";
    pptx.company = "StudyMate AI";
    pptx.title = `${fileName || 'StudyMate'} Flashcards`;
    
    flashcards.forEach((card, index) => {
      const slide = pptx.addSlide();
      
      // StudyMate header on each slide
      slide.addText("StudyMate", {
        x: 0.3, y: 0.2, w: 3, h: 0.6,
        fontSize: 20,
        bold: true,
        color: "6366F1",
        fontFace: "Arial"
      });
      
      // Card number
      slide.addText(`Card ${index + 1}`, {
        x: 0.3, y: 0.9, w: 8, h: 0.4,
        fontSize: 16,
        color: "8B5CF6",
        fontFace: "Arial"
      });
      
      // Term section
      slide.addText("TERM:", {
        x: 0.3, y: 1.5, w: 8, h: 0.4,
        fontSize: 14,
        bold: true,
        color: "6B7280",
        fontFace: "Arial"
      });
      
      slide.addText(card.term, {
        x: 0.3, y: 2.0, w: 8.5, h: 1.5,
        fontSize: 22,
        bold: true,
        color: "1F2937",
        fontFace: "Arial",
        valign: "top"
      });
      
      // Definition section
      slide.addText("DEFINITION:", {
        x: 0.3, y: 4.0, w: 8, h: 0.4,
        fontSize: 14,
        bold: true,
        color: "6B7280",
        fontFace: "Arial"
      });
      
      slide.addText(card.definition, {
        x: 0.3, y: 4.5, w: 8.5, h: 2.5,
        fontSize: 16,
        color: "374151",
        fontFace: "Arial",
        valign: "top"
      });
      
      // Footer
      slide.addText("Generated by StudyMate AI", {
        x: 0.3, y: 7.2, w: 8.5, h: 0.3,
        fontSize: 10,
        color: "9CA3AF",
        fontFace: "Arial",
        align: "center"
      });
    });
    
    // Generate PPTX as buffer
    const pptxBuffer = await pptx.write('nodebuffer');
    
    // Set proper headers for PPTX download
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.presentationml.presentation');
    res.setHeader('Content-Disposition', `attachment; filename="${fileName || 'StudyMate'}_flashcards.pptx"`);
    res.setHeader('Content-Length', pptxBuffer.length);
    
    // Send binary data
    res.send(pptxBuffer);
    
  } catch (error) {
    console.error('PPT generation error:', error);
    res.status(500).json({ error: 'Failed to generate PowerPoint: ' + error.message });
  }
});

// Images ZIP Export - Fixed
router.post("/images", async (req, res) => {
  try {
    const { flashcards, fileName } = req.body;
    const zip = new JSZip();
    
    for (let i = 0; i < flashcards.length; i++) {
      const card = flashcards[i];
      
      // Create front card image
      const frontCanvas = createCanvas(800, 500);
      const frontCtx = frontCanvas.getContext('2d');
      
      // Front gradient background
      const frontGradient = frontCtx.createLinearGradient(0, 0, 800, 500);
      frontGradient.addColorStop(0, '#6366F1');
      frontGradient.addColorStop(1, '#3B82F6');
      frontCtx.fillStyle = frontGradient;
      frontCtx.fillRect(0, 0, 800, 500);
      
      // StudyMate header
      frontCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      frontCtx.font = 'bold 22px Arial';
      frontCtx.fillText('StudyMate', 40, 60);
      
      // Card number
      frontCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      frontCtx.font = '16px Arial';
      frontCtx.textAlign = 'center';
      frontCtx.fillText(`Card ${i + 1}`, 400, 120);
      
      // TERM label
      frontCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      frontCtx.font = 'bold 18px Arial';
      frontCtx.fillText('TERM', 400, 160);
      
      // Term text
      frontCtx.fillStyle = 'white';
      frontCtx.font = 'bold 32px Arial';
      wrapText(frontCtx, card.term, 400, 220, 720, 45);
      
      // Instructions
      frontCtx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      frontCtx.font = '14px Arial';
      frontCtx.fillText('Click to reveal definition', 400, 460);
      
      const frontBuffer = frontCanvas.toBuffer('image/png');
      zip.file(`Card_${i + 1}_Front.png`, frontBuffer);
      
      // Create back card image
      const backCanvas = createCanvas(800, 500);
      const backCtx = backCanvas.getContext('2d');
      
      // Back gradient background
      const backGradient = backCtx.createLinearGradient(0, 0, 800, 500);
      backGradient.addColorStop(0, '#3B82F6');
      backGradient.addColorStop(1, '#1E40AF');
      backCtx.fillStyle = backGradient;
      backCtx.fillRect(0, 0, 800, 500);
      
      // StudyMate header
      backCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      backCtx.font = 'bold 22px Arial';
      backCtx.fillText('StudyMate', 40, 60);
      
      // Card number
      backCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      backCtx.font = '16px Arial';
      backCtx.textAlign = 'center';
      backCtx.fillText(`Card ${i + 1}`, 400, 120);
      
      // DEFINITION label
      backCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      backCtx.font = 'bold 18px Arial';
      backCtx.fillText('DEFINITION', 400, 160);
      
      // Definition text
      backCtx.fillStyle = 'white';
      backCtx.font = '22px Arial';
      wrapText(backCtx, card.definition, 400, 220, 720, 35);
      
      const backBuffer = backCanvas.toBuffer('image/png');
      zip.file(`Card_${i + 1}_Back.png`, backBuffer);
    }
    
    // Generate ZIP as buffer
    const zipBuffer = await zip.generateAsync({ type: 'nodebuffer' });
    
    // Set proper headers for ZIP download
    res.setHeader('Content-Type', 'application/zip');
    res.setHeader('Content-Disposition', `attachment; filename="${fileName || 'StudyMate'}_flashcards_images.zip"`);
    res.setHeader('Content-Length', zipBuffer.length);
    
    // Send binary data
    res.send(zipBuffer);
    
  } catch (error) {
    console.error('Images generation error:', error);
    res.status(500).json({ error: 'Failed to generate images: ' + error.message });
  }
});

// PDF Export (keep existing)
router.post("/pdf", async (req, res) => {
  try {
    const { flashcards, fileName } = req.body;
    
    const doc = new jsPDF();
    const pageHeight = doc.internal.pageSize.height;
    const pageWidth = doc.internal.pageSize.width;
    let yPosition = 20;
    
    // Add title
    doc.setFontSize(20);
    doc.setFont(undefined, 'bold');
    doc.text('StudyMate Flashcards', 20, yPosition);
    yPosition += 20;
    
    flashcards.forEach((card, index) => {
      if (yPosition > pageHeight - 60) {
        doc.addPage();
        yPosition = 20;
      }
      
      // Question/Term
      doc.setFontSize(16);
      doc.setFont(undefined, 'bold');
      doc.text(`Card ${index + 1}: ${card.term}`, 20, yPosition);
      
      // Answer/Definition
      doc.setFontSize(12);
      doc.setFont(undefined, 'normal');
      const splitAnswer = doc.splitTextToSize(card.definition, pageWidth - 40);
      doc.text(splitAnswer, 20, yPosition + 15);
      
      yPosition += 50 + (splitAnswer.length * 5);
      
      // Add separator line
      doc.line(20, yPosition - 10, pageWidth - 20, yPosition - 10);
    });
    
    const pdfBuffer = Buffer.from(doc.output('arraybuffer'));
    
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="${fileName || 'StudyMate'}_flashcards.pdf"`);
    res.send(pdfBuffer);
    
  } catch (error) {
    console.error('PDF generation error:', error);
    res.status(500).json({ error: 'Failed to generate PDF' });
  }
});

export default router;
